---
description: Master algorithm design, common algorithmic patterns, problem-solving techniques, and become proficient at solving computational challenges efficiently.
capabilities: ["algorithm-design", "problem-solving", "optimization", "dynamic-programming", "greedy-algorithms", "backtracking", "pattern-matching"]
---

# Algorithms & Problem Solving Expert

Become a master problem solver. Learn to design efficient algorithms and recognize patterns across diverse computational challenges.

## Fundamental Algorithm Patterns

### Searching & Sorting
- **Linear Search**: O(n) time complexity
- **Binary Search**: O(log n) time complexity, requires sorted data
- **Bubble Sort**: O(nÂ²), simple but inefficient
- **Merge Sort**: O(n log n), divide and conquer
- **Quick Sort**: O(n log n) average, partition-based
- **Heap Sort**: O(n log n), in-place sorting

### Divide and Conquer
- **General Principle**: Divide problem into subproblems, solve recursively, combine solutions
- **Examples**: Merge sort, quicksort, binary search, Strassen's matrix multiplication
- **Recurrence Relations**: Analyzing performance with Master Theorem

### Dynamic Programming
- **Memoization**: Top-down approach with caching
- **Tabulation**: Bottom-up iterative approach
- **Classic Problems**: Fibonacci, coin change, knapsack, longest subsequence
- **Optimal Substructure**: Identifying when DP applies
- **State Definition**: Defining DP states correctly

### Greedy Algorithms
- **Principle**: Make locally optimal choice at each step
- **Examples**: Activity selection, Huffman coding, Dijkstra's algorithm
- **Proving Correctness**: Greedy choice property and optimal substructure
- **When to Use**: Problem has optimal substructure and greedy choice property

### Backtracking
- **Principle**: Explore all solutions, backtrack when dead end
- **Examples**: N-Queens, permutations, Sudoku solver, maze solving
- **Pruning**: Cutting off branches early
- **State Space Tree**: Understanding the search tree

## Problem-Solving Strategy

### 1. Understand the Problem
- Read carefully and identify constraints
- Determine input/output specifications
- Find examples and edge cases

### 2. Plan Your Approach
- Identify algorithm pattern (search, sort, DP, greedy, etc.)
- Think about brute force first
- Look for optimization opportunities

### 3. Implement
- Write clean, modular code
- Handle edge cases
- Test with various inputs

### 4. Optimize
- Analyze time and space complexity
- Find bottlenecks
- Apply optimizations

### 5. Verify
- Test with examples
- Test with edge cases
- Verify complexity analysis

## Common Problem Types

### Sequence Problems
- Searching for elements
- Finding subsequences/subarrays
- Partitioning and merging

### Tree/Graph Problems
- Traversal (DFS, BFS)
- Path finding (shortest path, longest path)
- Topological sorting
- Cycle detection

### Arithmetic Problems
- Number manipulation
- Combinatorial problems
- Modular arithmetic

### String Problems
- Pattern matching
- Substring search
- Anagrams and permutations
- String transformation

## Classic Problem Categories

- **Fibonacci variants**
- **Coin change problem** (variations)
- **Longest common subsequence**
- **Edit distance**
- **Knapsack problem** (0/1 and unbounded)
- **Activity selection**
- **Job sequencing with deadlines**
- **Huffman coding**
- **Traveling salesman problem**

## Learning Progression

**Week 1-2: Sorting & Searching**
- Master common sorting algorithms
- Understand binary search variations

**Week 3-4: Divide & Conquer**
- Analyze recursive algorithms
- Master Master Theorem

**Week 5-7: Dynamic Programming**
- Understand memoization vs tabulation
- Solve 20+ DP problems

**Week 8-9: Greedy Algorithms**
- Recognize greedy problems
- Prove correctness

**Week 10-11: Backtracking**
- Solve constraint satisfaction problems
- Understand search space pruning

**Week 12: Advanced Topics**
- Network flows
- Graph algorithms
- String algorithms

## Practice Resources

- LeetCode: 200+ algorithm problems
- HackerRank: Structured algorithm learning
- CodeForces: Competitive programming
- GeeksforGeeks: Algorithm explanations

## Interview Prep

Be ready to solve:
- Median of two sorted arrays
- Longest substring without repeating characters
- Regular expression matching
- Trapping rain water
- Merge K sorted lists
- Word ladder
- Binary tree level order traversal
